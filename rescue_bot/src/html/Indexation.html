<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rescue Bot: Search and Rescue: How to create a multi-index</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rescue Bot: Search and Rescue
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Asearchandrescuerobotforuseinemergencyservices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">How to create a multi-index </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ALGO">Algorithm</a></li>
<li class="level1"><a href="#FORMATS">File formats</a></li>
<li class="level1"><a href="#EXAMPLE">Indexing sample</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ALGO"></a>
Algorithm</h1>
<p>The process of the multi-index construction is described in our <a href="http://download.yandex.ru/company/cvpr2012.pdf">paper</a>. Here we provide the details of the implementation.<br  />
<br  />
After the vocabularies are trained (see below), the index construction progress in two stages: assigning points to multi-index entries ("coarse quantization") and calculating information for reranking. Because one can use different reranking approaches for the same coarse quantization, the first stage of the algorithm saves the coarse quantizations for all points in the database to hard drive. These coarse quantizations are just the entry identifiers (e.g. codeword pairs). So if the file with coarse quantizations has already been produced there is no need to calculate them again (in this case, remove the flag &ndash;build_coarse from the command line parameters).<br  />
<br  />
In the CPU, a multi-index consists of a long onedimensional array containing the compressed points aligned by entries (i.e. a group of points belonging to the same entry is stored contiguously) and a table containing the starting index in the array for every entry of the multi-index. The class MultiIndexer is thus a C++ template by the type of the record in this array. In this way, you can easy implement your own reranking approach by defining new structure NewRecordType and implementing function GetRecord&lt;NewRecordType&gt; for your structure.<br  />
<br  />
For index contstruction you should provide coarse vocabularies for building the multi-index structure and fine vocabularies for calculating the reranking information (assuming that you are using the provided reranking procedure). We assume that these files are prepared outside this code (C++ is not the simplest way to create vocabularies, just for your reference we provide a MATLAB-script to create them below).<br  />
 </p>
<h1><a class="anchor" id="FORMATS"></a>
File formats</h1>
<p>Our code uses the <a href="http://corpus-texmex.irisa.fr">.bvecs</a> and <a href="http://corpus-texmex.irisa.fr">.fvecs</a> file formats developed by INRIA LEAR and TEXMEX groups.</p>
<ul>
<li><b>Coarse vocabularies</b><br  />
Our code assumes that coarse vocabularies are in the following format:<br  />
4 bytes(one int32) - number of items in each vocabulary (N)<br  />
4 bytes(one int32) - dimension of item (d)<br  />
4*N*d*M bytes(N*d*M floats) - vocabulary items one after another (M is the multiplicity of algorithm)<br  />
<br  />
Matlab script to build coarse vocabularies <div class="fragment"><div class="line">clear all;</div>
<div class="line"> </div>
<div class="line">all_data = bvecs_read(<span class="stringliteral">&#39;sift1M.bvecs&#39;</span>);</div>
<div class="line"> </div>
<div class="line">all_data = single(all_data);</div>
<div class="line">vocabSize = 4096;</div>
<div class="line">% add implementation of K-means</div>
<div class="line">vocab1 = your_kmeans(single(all_data(1:end/2,:)),vocabSize);</div>
<div class="line">vocab2 = your_kmeans(single(all_data(end/2+1:end,:)),vocabSize);</div>
<div class="line"> </div>
<div class="line">file = fopen([<span class="stringliteral">&#39;sift1M_double_4096_&#39;</span> num2str(vocabSize) <span class="stringliteral">&#39;.dat&#39;</span>], <span class="charliteral">&#39;w&#39;</span>);</div>
<div class="line">dim = size(vocab1, 1);</div>
<div class="line">sz = size(vocab1, 2);</div>
<div class="line">fwrite(file, dim, <span class="stringliteral">&#39;int32&#39;</span>);</div>
<div class="line">fwrite(file, sz, <span class="stringliteral">&#39;int32&#39;</span>);</div>
<div class="line">fwrite(file, vocab1, <span class="stringliteral">&#39;float&#39;</span>);</div>
<div class="line">fwrite(file, vocab2, <span class="stringliteral">&#39;float&#39;</span>);</div>
<div class="line">fclose(file);</div>
<div class="line">save([<span class="stringliteral">&#39;sift1M_double_4096_&#39;</span> num2str(vocabSize) <span class="stringliteral">&#39;.mat&#39;</span>], <span class="stringliteral">&#39;vocab1&#39;</span>, <span class="stringliteral">&#39;vocab2&#39;</span>);</div>
</div><!-- fragment --></li>
<li><b>Fine vocabularies</b><br  />
Our code assumes that fine vocabularies are in the following format:<br  />
4 bytes(one int32) - number of vocabularies (m)<br  />
4 bytes(one int32) - number of items in each vocabulary (N)<br  />
4 bytes(one int32) - dimension of item (d)<br  />
4*N*d*m bytes(N*d*m floats) - vocabulary items one after another<br  />
 Matlab script to build fine vocabularies (used <a href="http://www.vlfeat.org/">VlFeat</a> library) <div class="fragment"><div class="line">clear all;</div>
<div class="line">all_data = fvecs_read(<span class="stringliteral">&#39;sift1M.fvecs&#39;</span>);</div>
<div class="line"> </div>
<div class="line">vocabSize = 4096;</div>
<div class="line">load([<span class="stringliteral">&#39;sift1M_double_&#39;</span> num2str(vocabSize) <span class="stringliteral">&#39;.mat&#39;</span>], <span class="stringliteral">&#39;vocab1&#39;</span>, <span class="stringliteral">&#39;vocab2&#39;</span>);</div>
<div class="line"> </div>
<div class="line">vocab1 = int32(vocab1);</div>
<div class="line">vocab2 = int32(vocab2);</div>
<div class="line">i1 = vl_ikmeanspush(all_data(1:end/2,:), vocab1);</div>
<div class="line">i2 = vl_ikmeanspush(all_data(end/2+1:end,:), vocab2);  </div>
<div class="line">residual = single(all_data)- single([vocab1(:,i1); vocab2(:,i2)]);</div>
<div class="line">bytes_per_point = 8;    </div>
<div class="line"> </div>
<div class="line">D = size(residual,1) / bytes_per_point;</div>
<div class="line">residual_vocab = cell(bytes_per_point,1);</div>
<div class="line">dist = cell(bytes_per_point,1);</div>
<div class="line"><span class="keywordflow">for</span> m = 1:bytes_per_point</div>
<div class="line">    chunk = residual(D*m-D+1:D*m,:);</div>
<div class="line">    % add implementation of K-means</div>
<div class="line">    residual_vocab{m} = your_kmeans(chunk,256);</div>
<div class="line">    dist{m} = vl_alldist2(residual_vocab{m});          </div>
<div class="line">end</div>
<div class="line"> </div>
<div class="line">save([<span class="stringliteral">&#39;sift1M_double_4096_8.mat&#39;</span>],<span class="stringliteral">&#39;residual_vocab&#39;</span>,<span class="stringliteral">&#39;dist&#39;</span>);</div>
<div class="line"> </div>
<div class="line">file = fopen([<span class="stringliteral">&#39;sift1M_double_4096_8.dat&#39;</span>], <span class="charliteral">&#39;w&#39;</span>);</div>
<div class="line">vocabs_count = size(residual_vocab, 1);</div>
<div class="line">each_vocab_count = size(residual_vocab{1}, 2);</div>
<div class="line">each_vocab_dim = size(residual_vocab{1}, 1);</div>
<div class="line">fwrite(file, vocabs_count, <span class="stringliteral">&#39;int32&#39;</span>);</div>
<div class="line">fwrite(file, each_vocab_count, <span class="stringliteral">&#39;int32&#39;</span>);</div>
<div class="line">fwrite(file, each_vocab_dim, <span class="stringliteral">&#39;int32&#39;</span>);</div>
<div class="line"><span class="keywordflow">for</span> i = 1:vocabs_count</div>
<div class="line">    <span class="keywordflow">for</span> j = 1:each_vocab_count</div>
<div class="line">        a = residual_vocab{i}(:,j);</div>
<div class="line">        fwrite(file, a, <span class="stringliteral">&#39;float&#39;</span>);</div>
<div class="line">    end</div>
<div class="line">end</div>
<div class="line">fclose(file);</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="EXAMPLE"></a>
Indexing sample</h1>
<p>To build an invertered index for a set of points you should run "indexer_launcher" application with some command line parameters.</p>
<div class="fragment"><div class="line">--threads_count            - the number of threads to use <span class="keywordflow">for</span> the multi-threaded index construction</div>
<div class="line">--multiplicity             - the number of groups of dimensions the vectors will be split into. Equals 2 or 4 <span class="keywordflow">for</span> the experiments in the paper.</div>
<div class="line">--points_file              - the path to the file with the vector database (should be in .bvecs or .fvecs format)</div>
<div class="line">--coarse_vocabs_file       - the path to the file with the coarse vocabularies (see the format description above)</div>
<div class="line">--fine_vocabs_file         - the path to the file with fine vocabularies <span class="keywordflow">for</span> reranking (see the format description above)</div>
<div class="line">--input_point_type         - <span class="stringliteral">&quot;BVEC&quot;</span> or <span class="stringliteral">&quot;FVEC&quot;</span></div>
<div class="line">--points_count             - the number of points to index</div>
<div class="line">--space_dim                - the space dimensionality (e.g. 128 <span class="keywordflow">for</span> SIFTs)</div>
<div class="line">--files_prefix             - the common prefix <span class="keywordflow">for</span> storing the multi-index files (used to control runs with different parameters)</div>
<div class="line">--coarse_quantization_file - the path to the file with coarse quantizations</div>
<div class="line">--metainfo_file            - the path to the file with metainformation (deprecated, just write <span class="stringliteral">&quot;fake.txt&quot;</span>)</div>
<div class="line">--use_residuals            - the reranking method flag. Specify it <span class="keywordflow">if</span> you want to use residuals <span class="keywordflow">for</span> reranking (Multi-D-ADC) and omit it <span class="keywordflow">if</span> you want to use initial points (Multi-ADC)</div>
<div class="line">--build_coarse             - specify <span class="keyword">this</span> flag <span class="keywordflow">if</span> you want to recompute coarse quantizations (otherwise, will use the previously computed, <span class="keywordflow">if</span> available)</div>
</div><!-- fragment --><p>Windows users can try launch_indexer.bat script. It launches indexing of the <a href="http://corpus-texmex.irisa.fr/">ANN_SIFT1M dataset</a> using the provided vocabularies. Unix users should just write a similar launch_indexer.sh script. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
